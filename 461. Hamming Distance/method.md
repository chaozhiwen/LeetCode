<h2>问题</h2>
输入: x = 1, y = 4<br>
输出: 2<br>
解释:<br>
1   (0 0 0 1)<br>
4   (0 1 0 0)<br>
       ↑   ↑<br>
上面的箭头指出了对应二进制位不同的位置。
<h2>思路</h2>
对于两个二进制数来说，不可避免的会出现一个数字位多，而另一个少。我的解法是，利用两个队列，分别存入
两个二进制数的逆序。这里采用队列结构的好处是，可以从二进制数的最低位开始遍历。紧接着，两队列首元素
出列比较是否相同。只要有一个队列为空，说明此数所有位都遍历完成，接下来只需要判断另一队列中为1的位，
因为位数少的数，高位补零。<br>
<h2>算法复杂度</h2>
时间复杂度:O(log n)<br>
二进制数位入列O(log n)+出列比较O(log n)<br>
空间复杂度：O(log n)
