## 问题 ##
给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。
## 思路 ##
我发现了两种方法：  
**暴力法**  
1.遍历一次字符串，将字符C出现的所有位置放入一个容器中。  
2.再次遍历字符串，把当前元素的位置和容器中的位置一一做减法，找出最小的距离。  
**双指针**  
最短距离无非是当前字符左边或右边第一次发现字符C的距离。  
遍历字符串，每遍历到一个字符时，定义两个指针--左指针和右指针。左、右指针首先指向当前字符，左指针向左移动，右指针向右移动，分别找到第一次遇到字符C的位置，
然后比较左右指针指向位置到当前字符距离的大小，返回较小者。  
值得注意的是，每遍历到下一字符时，都应设置左指针和右指针大小--Integer.MAX_VALUE--2^31-1,并且左指针始终不会越过字符串的左边界，右指针始终不会越过字符串
的右边界。这么做的目的是防止当前元素的左边或右边不存在字符C。
## 算法复杂度 ##
暴力法  
**时间复杂度**&nbsp;O(n^2)  
步骤1&nbsp;O(n)  
步骤2&nbsp;O(n^2)  
**空间复杂度**&nbsp;O(n)
返回数组&nbsp;O(n)  
存放字符C的容器&nbsp;O(log n)  
***
双指针  
**时间复杂度**&nbsp;O(n)  
一次遍历  
**空间复杂度**&nbsp;O(n)
返回数组&nbsp;O(n)
